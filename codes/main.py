def run(system_config: dict, adapt_config: dict):

    import numpy as np 
    import os, csv

    from adapt_vqe import AdaptVQE
    from molecule import Molecule
    from adapt_setup import AdaptSetup
    from Ising import IsingModel
    import UsefulFunctions as uf

    script_dir = os.path.dirname(__file__)
    system_name = system_config['system_name']

    if system_config['system_name'][0:5] == 'Ising':
        system_config['ising'] = system_config.pop('system_name')
        ising = IsingModel(system_config)
        adapt_setup= AdaptSetup(adapt_config,
                            ising.nqubits)
        adapt = AdaptVQE(ising, adapt_setup)
        restart_indices, restart_optangles, result, reoptimised_minimums, reoptimised_thetas, noiseless_eigenvalues = adapt.compute_minimum_eigenvalue(ising.hamiltonian)
    else:
        system_config['molecule_name'] = system_config.pop('system_name')
        molecule = Molecule(system_config)
        adapt_setup= AdaptSetup(adapt_config,
                            molecule.nqubits, 
                            molecule.n_electrons)
        adapt = AdaptVQE(molecule, adapt_setup)
        restart_indices, restart_optangles, result, noiseless_eigenvalues, reoptimised_minimums, reoptimised_thetas = adapt.compute_minimum_eigenvalue(molecule.hamiltonian)

    #Data saving part
    if adapt_setup.shots is None:
        path = os.path.join(script_dir, f"simulations/data/{system_name}/noiseless")
    else:
        path = os.path.join(script_dir, f"simulations/data/{system_name}/{adapt_setup.shots}")
    print("simulation results saved at {}".format(path))
    os.makedirs(path, exist_ok=True)

    #Recovering data from the files generated by the simulation
    if adapt_setup.algorithm == 'adapt':
        real_eval_counts = uf.get_complete_eval_counts(adapt.adapt_counts)    
        real_mean_values = uf.get_real_mean_values(real_eval_counts, adapt.adapt_values)
        real_std_dev = uf.get_real_st_dev(real_eval_counts, adapt.adapt_std_dev)
    elif adapt_setup.algorithm == "gga" and adapt_setup.shots is not None and system_name[0:4] != 'Ising':
        real_mean_std_dev = uf.get_gga_mean_variances(adapt.min_metadata)
        real_std_dev = uf.get_gga_variances(adapt.min_metadata)
    elif adapt_setup.algorithm == 'gga' and adapt_setup.shots is not None and system_name[0:4] == 'Ising':
        real_std_dev = adapt.energy_variances
    elif adapt_setup.algorithm == "gga" and adapt_setup.shots == None:
        real_mean_std_dev = None
        real_std_dev = None

    if adapt_setup.algorithm == 'adapt':
        if system_name[0:5] != 'Ising':
            with open(path + f"/{adapt_setup.pool_name}_{adapt_config['optimizer']}_{adapt_config['noisy']}_adapt.csv", "w", encoding="UTF8") as file:
                writer = csv.writer(file)
                writer.writerow([result])
                writer.writerow(['Number of cost function evaluations per iterations:'])
                writer.writerow([real_eval_counts])
                writer.writerow(['Value of the variance for each iteration:'])
                writer.writerow([real_std_dev])
                writer.writerow(['Value of the exact energy from the noisy data:'])
                writer.writerow([noiseless_eigenvalues])
        else:
            with open(path + f"/{adapt_config['optimizer']}_{adapt_config['noisy']}_adapt.csv", "w", encoding="UTF8") as file:
                writer = csv.writer(file)
                writer.writerow([result])
                writer.writerow(['Number of cost function evaluations per iterations:'])
                writer.writerow([real_eval_counts])
                writer.writerow(['Value of the variance for each iteration:'])
                writer.writerow([real_std_dev])
                writer.writerow(['Value of the exact energy from the noisy data:'])
                writer.writerow([noiseless_eigenvalues])
    elif adapt_setup.algorithm == 'gga':
        if system_name[0:5] != 'Ising':
            with open(path + f"/{adapt_setup.pool_name}_{adapt_setup.optimizer}_gga.csv", "w", encoding="UTF8") as file:
                writer = csv.writer(file)
                writer.writerow([result])
                writer.writerow(['Values of the variance for each data points for each iteration:'])
                writer.writerow([real_std_dev])
                writer.writerow(['Mean Value of the variance for each iteration:'])
                writer.writerow([real_mean_std_dev])
                writer.writerow(['Value of the exact energy from the noisy data:'])
                writer.writerow([noiseless_eigenvalues])
                writer.writerow(['Values of the minimum energy at each step of re-optimization for each iteration'])
                writer.writerow([reoptimised_minimums])
                writer.writerow(['Values of the optimal angles at each step of re-optimization for each iteration'])
                writer.writerow([reoptimised_thetas])
        else:
            with open(path + f"/gga.csv", "w", encoding="UTF8") as file:
                writer = csv.writer(file)
                writer.writerow([result])
                writer.writerow(['Values of the variance for each data points for each iteration:'])
                writer.writerow([real_std_dev])
                writer.writerow(['Value of the exact energy from the noisy data:'])
                writer.writerow([noiseless_eigenvalues])

    file.close()

    #Restart file saving part
    uf.create_restart_file(path, restart_indices, restart_optangles)

if __name__ == "__main__":
    """Entrypoint (command line interface)"""

    import argparse

    # define the parser
    parser = argparse.ArgumentParser(
        epilog="ADAPT-VQE runner",
        usage="python main.py --help",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    group = parser.add_argument_group('Mandatory Input Options')
    group.add_argument(
        "-m",
        "--system_name",
        help="Name of the simulated system: can be either a molecule, e.g. H2, or a Ising chain, e.g.  Ising12 for 12 qubits/spins",
        type=str,
        required=True,
    )
    group.add_argument(
        "-a",
        "--algo",
        help="Type of VQE algorithm",
        choices=['adapt', 'gga'],
        type=str,
        required=True,
        default='adapt',
    )
    group.add_argument(
        "-o",
        "--optimizer",
        help="Classical method for the optimization process",
        choices=['COBYLA', 'BFGS', 'POWELL'],
        type=str,
        required=True,
    )
    group.add_argument(
        "-p",
        "--pool_name",
        help="Type of Pool used (SD or GSD)",
        choices=['SD', 'GSD', 'fermionic', 'ising_minimal'],
        type=str,
        required=True,
    )
    group.add_argument(
        "-n",
        "--adapt_max_iterations",
        help="Max number of ADAPT-VQE interations",
        type=int,
        required=True,
    )
    group = parser.add_argument_group('Optional Molecular Options')
    group.add_argument(
        "-s",
        "--spin_multiplicity",
        help="Value of the spin multiplicity of the molecule, 1 by default (for singlet)",
        type=int,
        required=False,
        default=1,
    )
    group.add_argument(
        "-c",
        "--charge",
        help="Charge of the molecule",
        type=int,
        required=False,
        default=0,
    )
    group.add_argument(
        "-b",
        "--basis",
        help="Basis set used for the simulation (sto-3g or 6-31G)",
        type=str,
        required=False,
        default='sto-3g'
    )
    group = parser.add_argument_group('Optional Ising Model Options')
    group.add_argument(
        "--coupling",
        help="Value of the Ising coupling",
        required=False,
        type=float,
        default=0.2,
    )
    group.add_argument(
        "--field",
        help="Value of the magnetic field",
        required=False,
        type=float,
        default=0.5,
    )
    group = parser.add_argument_group('Optional Algorithm Options')
    group.add_argument(
        "--grad_th",
        help="Value of the gradient threshold",
        type=float,
        default=1e-5,
        required=False,
    )
    group.add_argument(
        "--eigen_th",
        help="Value of the eigenvalue threshold (difference between two calculated eigenvalues)",
        type=float,
        default=1e-5,
        required=False,
    )
    group.add_argument(
        "--energy_th",
        help="Value of the energy threshold between calculated eigenvalue and fci energy",
        type=float,
        default=5e-5,
        required=False,
    )
    group.add_argument(
        "--method",
        help="Method of operator's implementation",
        required=False,
        type=str,
        default='evolution',
        choices=['evolution', 'circuit'],
    )
    group.add_argument(
        "--cpu_count",
        help="Number of cpus to use for parallel code",
        required=False,
        default=1,
        type=int,
    )
    group.add_argument(
        "--restart",
        help="Restart file containing ansatz operators and optimal angles",
        required=False,
        action='store_true',
    )
    group = parser.add_argument_group('Noisy Simulation Options')
    group.add_argument(
        "--shots",
        help="Number of shots in the simulation",
        type=float,
        required=False,
        default=0,
    )
    group.add_argument(
        "--noisy_value",
        help="Indicates if full noisy simulation or only vqe noisy for the adapt-vqe simulation",
        required=False,
        type=str,
        default='vqe',
        choices=['vqe', 'full']
    )
    group.add_argument(
        "--reoptimisation",
        help="If used, will performed the reoptimisation process for the GGA algorithm",
        required=False,
        action="store_true",
    )
    group.add_argument(
        "--adapt_1d",
        help="If used, 1D optimisation for ADAPT-VQE procedure",
        required=False,
        action="store_true",
    )
    
    # parse the input values
    args = parser.parse_args()

    system_config = {
            'system_name'   : args.system_name,
            'charge'        : args.charge,
            'multiplicity'  : args.spin_multiplicity,
            'basis'         : args.basis,
            'field'         : args.field,
            'coupling'      : args.coupling,
            }

    adapt_config = {
            'max_iterations'        : args.adapt_max_iterations,
            'pool_name'             : args.pool_name,
            'algorithm'             : args.algo,
            'optimizer'             : args.optimizer,
            'shots'                 : args.shots,
            'gradient_threshold'    : args.grad_th,
            'eigenvalue_threshold'  : args.eigen_th,
            'energy_threshold'      : args.energy_th,
            'restart'               : args.restart,
            'cpu_count'             : args.cpu_count,
            'noisy'                 : args.noisy_value,
            'method'                : args.method,
            'reoptimisation'        : args.reoptimisation,
            'adapt1d'               : args.adapt_1d,
            }

    # Run the ADAPT-VQE driver
    run(system_config, adapt_config)